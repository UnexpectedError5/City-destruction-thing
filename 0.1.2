<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>City Smash Sandbox</title>

<style>
body { margin: 0; overflow: hidden; background: black; }

#crosshair {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 18px;
  height: 18px;
  transform: translate(-50%, -50%);
  pointer-events: none;
}
#crosshair::before,
#crosshair::after {
  content: "";
  position: absolute;
  background: white;
}
#crosshair::before { width: 2px; height: 18px; left: 8px; }
#crosshair::after { width: 18px; height: 2px; top: 8px; }
</style>
</head>

<body>
<div id="crosshair"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
/* =====================
   CORE
===================== */
let scene, camera, renderer;
let player;
let buildings = [];
let keys = {};
let yaw = 0, pitch = 0;
let velY = 0;
let canJump = true;

/* =====================
   HAMMER
===================== */
let hammerHolder;
let swinging = false;
let swingT = 0;
const SMASH_RANGE = 7;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 6000);

  player = new THREE.Object3D();
  player.position.set(0, 4, 20);
  player.add(camera);
  scene.add(player);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(400, 700, 400);
  scene.add(sun);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(6000, 6000),
    new THREE.MeshStandardMaterial({ color: 0x555555 })
  );
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  generateCity();
  createHammer();

  document.body.addEventListener("click", () => {
    document.body.requestPointerLock();
    startSwing();
    smash();
  });

  document.addEventListener("mousemove", look);
  window.addEventListener("keydown", e => keys[e.code] = true);
  window.addEventListener("keyup", e => keys[e.code] = false);
  window.addEventListener("resize", onResize);
}

/* =====================
   DENSE CONCRETE + GLASS CITY
===================== */
function generateCity() {
  const spacing = 55;
  const size = 400;

  const glassMat = new THREE.MeshStandardMaterial({
    color: 0x9bb6d6,
    roughness: 0.2,
    metalness: 0.7,
    transparent: true,
    opacity: 0.85
  });

  const concreteMat = new THREE.MeshStandardMaterial({
    color: 0x777777,
    roughness: 0.95
  });

  for (let x = -size; x <= size; x += spacing) {
    for (let z = -size; z <= size; z += spacing) {
      if (Math.random() < 0.2) continue;

      const height = Math.random() * 180 + 220;
      const width = Math.random() * 22 + 26;

      const tower = new THREE.Group();

      // Glass body
      const body = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, width),
        glassMat
      );
      body.position.y = height / 2;
      tower.add(body);

      // Horizontal concrete floor bands
      const floors = Math.floor(height / 18);
      for (let i = 1; i < floors; i++) {
        const band = new THREE.Mesh(
          new THREE.BoxGeometry(width + 0.6, 0.6, width + 0.6),
          concreteMat
        );
        band.position.y = i * (height / floors);
        tower.add(band);
      }

      // Vertical concrete columns (same color as floor bands)
      const columns = 4;
      for (let i = 0; i < columns; i++) {
        const offset = -width / 2 + (i + 1) * (width / (columns + 1));

        const colX = new THREE.Mesh(
          new THREE.BoxGeometry(0.6, height, width + 0.6),
          concreteMat
        );
        colX.position.set(offset, height / 2, 0);
        tower.add(colX);

        const colZ = colX.clone();
        colZ.rotation.y = Math.PI / 2;
        colZ.position.set(0, height / 2, offset);
        tower.add(colZ);
      }

      // Door (visual only)
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(3, 5, 0.3),
        concreteMat
      );
      door.position.set(0, 2.5, width / 2 + 0.16);
      tower.add(door);

      tower.position.set(x, 0, z);
      tower.userData = {
        vel: new THREE.Vector3(),
        half: width / 2
      };

      buildings.push(tower);
      scene.add(tower);
    }
  }
}

/* =====================
   HAMMER
===================== */
function createHammer() {
  hammerHolder = new THREE.Object3D();
  hammerHolder.position.set(0.6, -0.2, -0.7);
  hammerHolder.rotation.x = -0.5;
  camera.add(hammerHolder);

  const hammer = new THREE.Group();

  const handle = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8),
    new THREE.MeshStandardMaterial({ color: 0x4b2e1e })
  );
  handle.position.y = -0.6;
  hammer.add(handle);

  const head = new THREE.Mesh(
    new THREE.BoxGeometry(0.25, 0.25, 0.45),
    new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
  );
  head.position.y = 0.15;
  hammer.add(head);

  hammerHolder.add(hammer);
}

/* =====================
   INPUT + MOVE
===================== */
function look(e) {
  if (document.pointerLockElement !== document.body) return;
  yaw -= e.movementX * 0.002;
  pitch -= e.movementY * 0.002;
  pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
  player.rotation.y = yaw;
  camera.rotation.x = pitch;
}

function move() {
  const baseSpeed = 0.3;
  const sprint = keys.ShiftLeft || keys.ShiftRight ? 1.8 : 1;
  const speed = baseSpeed * sprint;

  let moveVec = new THREE.Vector3();
  const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right = new THREE.Vector3(forward.z, 0, -forward.x);

  if (keys.KeyW) moveVec.addScaledVector(forward, -speed);
  if (keys.KeyS) moveVec.addScaledVector(forward, speed);
  if (keys.KeyA) moveVec.addScaledVector(right, -speed);
  if (keys.KeyD) moveVec.addScaledVector(right, speed);

  let nextPos = player.position.clone().add(moveVec);
  buildings.forEach(b => {
    const dx = nextPos.x - b.position.x;
    const dz = nextPos.z - b.position.z;
    if (Math.max(Math.abs(dx), Math.abs(dz)) < b.userData.half + 1.2) {
      moveVec.set(0, 0, 0);
    }
  });

  player.position.add(moveVec);

  velY -= 0.015;
  player.position.y += velY;

  if (player.position.y < 4) {
    player.position.y = 4;
    velY = 0;
    canJump = true;
  }

  if (keys.Space && canJump) {
    velY = 0.35;
    canJump = false;
  }
}

/* =====================
   HAMMER + SMASH
===================== */
function startSwing() {
  if (swinging) return;
  swinging = true;
  swingT = 0;
}

function updateHammer() {
  if (!swinging) return;
  swingT += 0.12;

  if (swingT < 1) {
    hammerHolder.rotation.x =
      -0.5 - Math.sin(swingT * Math.PI) * 2.2;
  } else {
    hammerHolder.rotation.x *= 0.85;
    if (hammerHolder.rotation.x > -0.51) {
      hammerHolder.rotation.x = -0.5;
      swinging = false;
    }
  }
}

function smash() {
  const ray = new THREE.Raycaster();
  ray.setFromCamera(new THREE.Vector2(0, 0), camera);
  ray.far = SMASH_RANGE;

  const hits = ray.intersectObjects(scene.children, true);
  if (!hits.length) return;

  const hit = hits[0].object.parent;
  if (!hit.userData?.vel) return;

  const force = new THREE.Vector3()
    .subVectors(hit.position, player.position)
    .normalize()
    .multiplyScalar(5);
  force.y += 4;

  hit.userData.vel.add(force);
}

/* =====================
   PHYSICS
===================== */
function updateBuildings() {
  buildings.forEach(b => {
    b.userData.vel.y -= 0.05;
    b.position.add(b.userData.vel);

    if (b.position.y < 0) {
      b.position.y = 0;
      b.userData.vel.multiplyScalar(0.4);
      b.userData.vel.y *= -0.2;
    }
  });
}

/* =====================
   LOOP
===================== */
function animate() {
  requestAnimationFrame(animate);
  move();
  updateHammer();
  updateBuildings();
  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}
</script>
</body>
</html>
