<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>City Smash Sandbox</title>

<style>
body { margin: 0; overflow: hidden; background: black; }

#crosshair {
  position: fixed;
  top: 50%;
  left: 50%;
  width: 18px;
  height: 18px;
  transform: translate(-50%, -50%);
  pointer-events: none;
}
#crosshair::before,
#crosshair::after {
  content: "";
  position: absolute;
  background: white;
}
#crosshair::before { width: 2px; height: 18px; left: 8px; }
#crosshair::after { width: 18px; height: 2px; top: 8px; }
</style>
</head>

<body>
<div id="crosshair"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
/* =====================
   CORE
===================== */
let scene, camera, renderer;
let player;
let buildings = [];
let keys = {};
let yaw = 0, pitch = 0;
let velY = 0;
let canJump = true;

/* =====================
   HAMMER
===================== */
let hammerHolder;
let swinging = false;
let swingT = 0;

const SMASH_RANGE = 8;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 6000);

  player = new THREE.Object3D();
  player.position.set(0, 4, 30);
  player.add(camera);
  scene.add(player);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const sun = new THREE.DirectionalLight(0xffffff, 1);
  sun.position.set(300, 500, 300);
  scene.add(sun);

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(6000, 6000),
    new THREE.MeshStandardMaterial({ color: 0x555555 })
  );
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  generateCity();
  createHammer();

  document.body.addEventListener("click", () => {
    document.body.requestPointerLock();
    startSwing();
    smash();
  });

  document.addEventListener("mousemove", look);
  window.addEventListener("keydown", e => keys[e.code] = true);
  window.addEventListener("keyup", e => keys[e.code] = false);
  window.addEventListener("resize", onResize);
}

/* =====================
   CITY
===================== */
function generateCity() {
  const spacing = 70;
  const size = 500;

  for (let x = -size; x <= size; x += spacing) {
    for (let z = -size; z <= size; z += spacing) {
      if (Math.random() < 0.3) continue;

      const height = Math.random() * 150 + 120;
      const width = Math.random() * 30 + 30;

      const building = new THREE.Mesh(
        new THREE.BoxGeometry(width, height, width),
        new THREE.MeshStandardMaterial({ color: 0x888888 })
      );

      building.position.set(x, height / 2, z);
      building.userData = {
        vel: new THREE.Vector3(),
        half: width / 2
      };

      buildings.push(building);
      scene.add(building);
    }
  }
}

/* =====================
   HAMMER (LOCKED)
===================== */
function createHammer() {
  hammerHolder = new THREE.Object3D();
  hammerHolder.position.set(0.6, -0.15, -0.7);
  hammerHolder.rotation.x = -0.4;
  camera.add(hammerHolder);

  const hammer = new THREE.Group();

  const handle = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8),
    new THREE.MeshStandardMaterial({ color: 0x4b2e1e })
  );
  handle.position.y = -0.6;
  hammer.add(handle);

  const head = new THREE.Mesh(
    new THREE.BoxGeometry(0.25, 0.25, 0.45),
    new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
  );
  head.position.y = 0.15;
  hammer.add(head);

  hammerHolder.add(hammer);
}

/* =====================
   INPUT
===================== */
function look(e) {
  if (document.pointerLockElement !== document.body) return;
  yaw -= e.movementX * 0.002;
  pitch -= e.movementY * 0.002;
  pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
  player.rotation.y = yaw;
  camera.rotation.x = pitch;
}

/* =====================
   MOVE + SPRINT + COLLISION
===================== */
function move() {
  const baseSpeed = 0.3;
  const sprintMultiplier = keys.ShiftLeft || keys.ShiftRight ? 1.8 : 1;
  const speed = baseSpeed * sprintMultiplier;

  let moveVec = new THREE.Vector3();

  const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right = new THREE.Vector3(forward.z, 0, -forward.x);

  if (keys.KeyW) moveVec.addScaledVector(forward, -speed);
  if (keys.KeyS) moveVec.addScaledVector(forward, speed);
  if (keys.KeyA) moveVec.addScaledVector(right, -speed);
  if (keys.KeyD) moveVec.addScaledVector(right, speed);

  let nextPos = player.position.clone().add(moveVec);
  buildings.forEach(b => {
    const dx = nextPos.x - b.position.x;
    const dz = nextPos.z - b.position.z;
    if (Math.max(Math.abs(dx), Math.abs(dz)) < b.userData.half + 1) {
      moveVec.set(0, 0, 0);
    }
  });

  player.position.add(moveVec);

  velY -= 0.015;
  player.position.y += velY;

  if (player.position.y < 4) {
    player.position.y = 4;
    velY = 0;
    canJump = true;
  }

  if (keys.Space && canJump) {
    velY = 0.35;
    canJump = false;
  }
}

/* =====================
   HAMMER ANIMATION
===================== */
function startSwing() {
  if (swinging) return;
  swinging = true;
  swingT = 0;
}

function updateHammer() {
  if (!swinging) return;

  swingT += 0.12;

  if (swingT < 1) {
    hammerHolder.rotation.x =
      -0.4 - Math.sin(swingT * Math.PI) * 2.0;
  } else {
    hammerHolder.rotation.x *= 0.85;
    if (hammerHolder.rotation.x > -0.41) {
      hammerHolder.rotation.x = -0.4;
      swinging = false;
    }
  }
}

/* =====================
   SMASH (LIMITED RANGE)
===================== */
function smash() {
  const ray = new THREE.Raycaster();
  ray.setFromCamera(new THREE.Vector2(0, 0), camera);
  ray.far = SMASH_RANGE;

  const hits = ray.intersectObjects(buildings);
  if (!hits.length) return;

  const b = hits[0].object;
  const force = new THREE.Vector3()
    .subVectors(b.position, player.position)
    .normalize()
    .multiplyScalar(6);
  force.y += 4;

  b.userData.vel.add(force);
}

/* =====================
   BUILDING PHYSICS
===================== */
function updateBuildings() {
  buildings.forEach(b => {
    b.userData.vel.y -= 0.05;
    b.position.add(b.userData.vel);

    const floor = b.geometry.parameters.height / 2;
    if (b.position.y < floor) {
      b.position.y = floor;
      b.userData.vel.multiplyScalar(0.4);
      b.userData.vel.y *= -0.2;
    }
  });
}

/* =====================
   LOOP
===================== */
function animate() {
  requestAnimationFrame(animate);
  move();
  updateHammer();
  updateBuildings();
  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}
</script>
</body>
</html>
